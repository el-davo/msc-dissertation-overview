\chapter{Introduction}
\lhead{\emph{Introduction}}

Microservice architectures have been widely adopted over the past decade \cite{7030212}. Monolithic architectures require all code to be compiled into one single artifact. In contrast, applications built using a microservice architecture decompose the key parts of monolithic applications into smaller independent services. 

Microservice architectures are easier to scale than their monolithic counterparts \cite{namiot2014micro}. If developers detect that a service is under heavy load they can add more instances of that particular service, this is known as horizontal scaling. For a monolithic application to scale a developer would have to add more instances of the entire application, this is known as vertical scaling. 

Monolithic architectures are typically written in one programming language, this can be problematic as there is no one language that is suitable for every use case. Once developers have committed to using one language it is very hard to back out and use another language should requirements change. With microservices, developers have more freedom sue to their inherent separation of concerns, if requirements change they can easily add new services written in a different language, and because services can be very small in size it is not uncommon to re-write services from scratch using a new language.

In terms of agility, microservices are widely accepted to be more in line with agile practices than monolithic architectures \cite{larrucea2018microservices}. This is due to the high degree of decoupling between services. In many companies, there may be a single team assigned to one service.

Microservices do have some disadvantages. In larger applications, there may be hundreds of services running. This makes automated monitoring of services very difficult when compared to monolithic applications which require monitoring a single service \cite{mayer2017dashboard}. A similar problem arises for debugging of applications. In a monolithic architecture, a developer only needs to view a single log file, however, in a microservice architecture, they will need to view log files coming from many services. 

Traffic monitoring is another problem for microservices \cite{sun2015security}. An example of this would be in a web application. If a user connects to a web interface, they may make a network request to login to the application. The network request may enter the microservice system and be forwarded on to any number of services before responding to a users request. Tracing the flow of network requests through the system and understanding how each service is affected is important in maintaining a healthy, scalable system. 

Test-driven development (TDD) in microservice architectures is a good way to try and circumvent some of these problems. By utilizing TDD, developers have re-assurance that artifacts they are releasing to production environments are in working order. TDD comes in a variety of forms, such as unit, integration and end-to-end testing \cite{7160271}. There is also another form of testing known as stress testing which is the focus of this dissertation. 

Stress testing involves simulating a high level of traffic to see if a system can handle certain loads. This is an important metric for developers. This form of testing provides developers with reassurance that the system they are building can handle the number of users they are expecting. Without stress testing, it is highly likely that the system will experience outages due to its inability to handle heavy user load, which can lead to financial loss when building e-commerce systems, as well as the cost of debugging and potentially re-writing parts of a system.

There are a number of tools available for stress testing applications. Apache JMeter is one such tool \cite{jmeter}. These tools offer the ability to simulate high levels of traffic. They summarize the limits of an application such as how many requests made successful connections and how many requests failed. While this is useful it does not provide any insights into how services within a microservice architecture have reacted to the test. An approach that could perform both stress testing and can also give insights into how microservices react to varying loads across services could provide an enhanced understanding of the suitability and efficacy of an architectural design. 

To demonstrate this approach, a tool that can stress test web sockets deployed in a microservice environment while monitoring services individually within a system has been developed.

\section{Motivation}

As it stands, there are no tools on the market, that can combine both stress testing and monitoring of a microservice environment. The intended beneficiaries of this tool are developers utilizing web sockets who wish to gain deeper insights into how large user bases will affect their systems. As more companies adopt agile methodologies such as continuous delivery, there is a greater need to actively test their software before it reaches production to prevent any degradation in performance.

The second motivation for designing and developing this platform, is to easily allow developers to adopt stress testing. Testing methods such as unit tests and integration tests are widely used, however in many cases stress testing is often seen as an afterthought. A recent survey determined this to be true, concluding that only one third of companies have an a stress testing strategy in place \cite{bezemer2019performance}.

\section{Research Questions and Objectives}

\subsection{Research Question}

As production level software increasingly relies on websockets in microservice environments. The inherent complexity of this paradigm necessetates a deep understanding of software development and the archetrictural design of software. One area of complexity where this is demonstrated is the evaluation of how websocket protocols would perform between services under varying loads. 

As such the question is asked. Can an integrated development tool be designed such that the complexity involved in evaluating a microservice architecture implementation of a websocket protocol can be carried out in a simplified and automated manner?

The aim of this project is to design and develop a web socket stress testing tool that can also monitor microservice environments and each of the underlying services in order to give developers a greater understanding of how large amounts of traffic can affect their environments.

\subsection{Research Objectives}

\begin{itemize}
  \item To gain an appreciation for the underlying limitations of development in a microservice environment.
  \item To research and develop a web socket stress testing tool that can also monitor microservice environments.
  \item Summarize results of a test to a developer using an intuitive interface.
  \item Test the system using a variety of WebSocket server implementations. Using GoLang and NodeJS to see how scalable the platform is.
  \item To research and develop integrate the platform with existing continuous integration tools.
\end{itemize}

\subsection{Structure of this document}

Chapter 1 describes the objects of this dissertation, and introduces microservices. Chapter 2 details the background research into the various technologies that are utilized in microservices and web sockets as well as a discussion of how they have evolved over time. Chapter 3 details the design and development of a stress testing framework, detailing the technologies used and the motivation behind each chosen technology. Chapter 4 presents the results of developing the stress testing tool as well as giving a comparison of each of the various web socket implementations between different languages. Chapter 5 discusses the conclusions and finding of this research as well as detailing future work.